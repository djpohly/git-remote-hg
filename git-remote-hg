#!/usr/bin/env python2
"""Used by git-remote to interact with remote Mercurial repositories.

This command should not be run by the user.  Rather, it is invoked by
the Git core when accessing remotes of the form `hg::HGURL', where
HGURL is any valid Mercurial repository URL.

Executed with two arguments: the name of the remote, and the remote
URL.  (For URLs specified directly on the command line, the name of
the remote is `hg::HGURL'.)
"""


from __future__ import print_function

import sys
from mercurial import hg, ui, node


verbosity = 1
dryrun = False

def die(msg):
	progname = sys.argv[0].rsplit("/", 1)[-1]
	print("%s: %s" % (progname, msg), file=sys.stderr)
	sys.exit(1)

def dbgprint(*vals, **kwargs):
	print(*vals, file=sys.stderr, **kwargs)
	print(*vals, **kwargs)

def option_verbosity(val):
	try:
		verbosity = int(val)
	except ValueError:
		dbgprint("error verbosity not a number")
	else:
		dbgprint("ok")
	sys.stdout.flush()

def option_dryrun(val):
	if val == "true":
		dryrun = True
	elif val == "false":
		dryrun = False
	else:
		dbgprint("error dry-run not true|false")
		return
	dbgprint("ok")
	sys.stdout.flush()


class hgremote(object):
	def __init__(self, hgui, url, name):
		self.ui = hgui
		self.peer = hg.peer(self.ui, {}, url)
		self.name = name
		self.refmap = {}

	def capabilities(self):
		dbgprint("option")
		dbgprint("import")
		dbgprint("push")
		if self.name:
			dbgprint("refspec refs/heads/*:refs/remotes/%s/*" % self.name)
		dbgprint()
		sys.stdout.flush()

	def list(self):
		self.refmap = {}
		# Give bookmarks priority
		for name, sha in self.peer.listkeys("bookmarks").iteritems():
			self.refmap["bm/" + name] = sha
		seen = set(self.refmap.values())

		# branchmap() returns heads in recency order, tip first
		for name, heads in self.peer.branchmap().iteritems():
			i = 0
			for binsha in set(heads) - seen:
				self.refmap["br/" + name + "/" + str(i)] = node.hex(binsha)
				i += 1
		dbgprint(*["? " + name for name in self.refmap.iterkeys()], sep="\n")

		# What do we want to map HEAD to?
		# - Tipmost revision?  Possible, but probably not what we want.
		# - Tipmost revision on default branch?  More Git-like.
		# - Depends on TKPA of previous remote HEAD?  Sounds plausible.
		self.refmap["HEAD"] = self.refmap["br/default/0"]
		dbgprint("@br/default/0 HEAD")

		dbgprint()
		sys.stdout.flush()

	def fastimport(self, ref):
		die("import not yet implemented")

	def push(self, ref):
		die("push not yet implemented")


def main():
	"""Main function for Mercurial helper."""
	# Arguments should be:
	# 1. Name of remote, or full remote URL (with "hg::" prefix)
	# 2. Remote URL without prefix
	if len(sys.argv) != 3:
		die("expecting exactly two arguments")

	# ':' is illegal in Git refs but required in full URLs, so we
	# can use it to distinguish them here.
	rname = sys.argv[1] if ":" not in sys.argv[1] else None

	# Set up Mercurial objects: ui is settings/context, and peer is the remote
	hgui = ui.ui()
	# XXX set up proxy options and other stuff in ui
	remote = hgremote(hgui, sys.argv[2], rname)

	# Handle commands issued by Git
	cmd = sys.stdin.readline().split(None, 1)
	while cmd:
		print(cmd, file=sys.stderr)

		if cmd[0] == "capabilities":
			remote.capabilities()
		elif cmd[0] == "list":
			remote.list()
		elif cmd[0] == "import":
			remote.fastimport(cmd[1])
		elif cmd[0] == "push":
			remote.push(cmd[1])
		elif cmd[0] == "option":
			args = cmd[1].split(None, 1)
			if args[0] == "verbosity":
				option_verbosity(args[1])
			elif args[0] == "dry-run":
				option_dryrun(args[1])
			else:
				dbgprint("unsupported\n")
			sys.stdout.flush()
		else:
			die("unrecognized command `%s'" % cmd[0])
		cmd = sys.stdin.readline().split(None, 1)


if __name__ == "__main__":
	main()
