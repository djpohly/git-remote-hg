#!/usr/bin/env python2
"""Used by git-remote to interact with remote Mercurial repositories.

This command should not be run by the user.  Rather, it is invoked by
the Git core when accessing remotes of the form `hg::HGURL', where
HGURL is any valid Mercurial repository URL.

Executed with two arguments: the name of the remote, and the remote
URL.  (For URLs specified directly on the command line, the name of
the remote is `hg::HGURL'.)
"""


from __future__ import print_function

import sys, collections, subprocess
import mercutil as hg


Rev = collections.namedtuple("Rev", ["delta", "nodeid", "p1", "p2", "cs"])

verbosity = 1
dryrun = False

def die(msg):
	progname = sys.argv[0].rsplit("/", 1)[-1]
	print("%s: %s" % (progname, msg), file=sys.stderr)
	sys.exit(1)

def dbgprint(*vals, **kwargs):
	print(*vals, file=sys.stderr, **kwargs)
	print(*vals, **kwargs)

def option_verbosity(val):
	try:
		verbosity = int(val)
	except ValueError:
		dbgprint("error verbosity not a number")
	else:
		dbgprint("ok")

def option_dryrun(val):
	if val == "true":
		dryrun = True
		dbgprint("ok")
	elif val == "false":
		dryrun = False
		dbgprint("ok")
	else:
		dbgprint("error dry-run not true|false")


class HgRemote(object):
	def __init__(self, hgui, url, name):
		self.ui = hgui
		self.peer = hg.Peer(self.ui, url)
		self.name = name
		self.refmap = {}

	def capabilities(self):
		#dbgprint("option")
		dbgprint("fetch")
		dbgprint("import")
		dbgprint("push")
		if self.name:
			dbgprint("refspec refs/heads/*:refs/remotes/%s/*" %
			         self.name)
		dbgprint()
		sys.stdout.flush()

	def list(self):
		self.refmap = {}
		seen = set()
		# Give bookmarks priority
		for name, sha in self.peer.bookmarks().iteritems():
			self.refmap["bm/" + name] = sha
			seen.add(sha)

		# branchmap() returns heads in recency order, tip first
		branchmap = self.peer.branchmap()
		for name, heads in branchmap.iteritems():
			for i, sha in enumerate([h for h in heads
			                         if h not in seen]):
				self.refmap["br/" + name + "/" + str(i)] = sha
		dbgprint(*["? " + name for name in self.refmap.iterkeys()],
		         sep="\n")

		# What do we want to map HEAD to?
		# - Tipmost revision on default branch?  Good for initial
		#   clone.
		# - Depends on TKPA of previous remote HEAD?  Sounds plausible.
		self.refmap["HEAD"] = branchmap["default"][0]
		dbgprint("? HEAD")

		dbgprint()
		sys.stdout.flush()

	def fastimport(self, ref):
		die("import not yet implemented")

	def push(self, ref):
		die("push not yet implemented")

def rawtree(treeish, recurse=False):
	# XXX CalledProcessError here means treeish not found/valid
	args = ["git", "ls-tree", treeish]
	if recurse:
		args.append("-r")
	return (l[:-1].split(None, 3) for l in subprocess.Popen(args,
			bufsize=1, stdout=subprocess.PIPE).stdout)
def rawblob(obj):
	# XXX CalledProcessError here means object not found/valid
	args = ["git", "cat-file", "blob", obj]
	return subprocess.check_output(args)

class Ftree(object):
	def __init__(self, sha, nodeid, extra):
		self.sha = sha
		self.nodeid = nodeid
		self.extra = extra
	def fromsha(treesha):
		tree = rawtree(treesha)
		sha = nodeid = None
		extra = {}
		for ent in tree:
			# XXX CalledProcessError here means git repo corrupted
			# (sub-objects lost)
			if ent[3] == "sha":
				sha = rawblob(ent[2])
			elif ent[3] == "nodeid":
				nodeid = rawblob(ent[2])
			elif ent[3].startswith("extra."):
				name = ent[3][6:].replace(": ", "/")
				extra[name] = rawblob(ent[2])
		return sha and nodeid and Ftree(sha, nodeid, extra)
	def text(self):
		return hg.buildfile(rawblob(self.sha), self.extra)
class Mtree(object):
	def __init__(self, sha, nodeid, files):
		self.sha = sha
		self.nodeid = nodeid
		self.files = files
	def fromsha(treesha):
		tree = rawtree(treesha, recurse=True)
		sha = nodeid = None
		files = {}
		for ent in tree:
			# XXX CalledProcessError here means git repo corrupted
			# (sub-objects lost)
			if ent[3] == "sha":
				sha = rawblob(ent[2])
			elif ent[3] == "nodeid":
				nodeid = rawblob(ent[2])
			elif ent[3].startswith("file/") and \
			     ent[3].endswith("/nodeid"):
				files[ent[3][5:-7]] = rawblob(ent[2])
		return sha and nodeid and Mtree(sha, nodeid, files)
class Ctree(object):
	def __init__(self, sha, nodeid, mf, extra):
		self.sha = sha
		self.nodeid = nodeid
		self.mf = mf
		self.extra = extra
	def fromsha(treesha):
		tree = rawtree(treesha)
		sha = nodeid = mf = None
		extra = {}
		for ent in tree:
			# XXX CalledProcessError here means git repo corrupted
			# (sub-objects lost)
			if ent[3] == "sha":
				sha = rawblob(ent[2])
			elif ent[3] == "nodeid":
				nodeid = rawblob(ent[2])
			elif ent[3] == "mf":
				mf = rawblob(ent[2])
			elif ent[3].startswith("extra."):
				name = ent[3][6:].replace(": ", "/")
				extra[name] = rawblob(ent[2])
		return sha and nodeid and mf and Ctree(sha, nodeid, mf, extra)

class RevMap(object):
	def __init__(self, ref):
		self.revs = {e[3]: e[2] for e in rawtree(ref)}
		self.cache = {}
		self.new = {}
	def get(self, idorsha, func):
		# func is read[cmf]tree
		tree = self.new.get(idorsha) or self.cache.get(idorsha)
		if tree:
			return tree
		tree = func(self.revs[idorsha])
		cache[idorsha] = tree
		return tree
	def add(self, idorsha, tree):
		# If we do add a duplicate, it had better be exactly the same
		test = self.new.setdefault(tree)
		assert test.nodeid == tree.nodeid

RevLog = collections.namedtuple("RevLog", ["log", "base"])
class RevCache(object):
	def __init__(self, revmap):
		self.csets = None
		self.mfs = None
		self.files = {}
		self.revmap = revmap
	def addcset(self, text, p1, p2):
		try:
			log, base = self.csets
		except TypeError:
			log = []
			if p1 == hg.NULLID:
				base = ""
			else:
				base = self.revmap.get(p1, Ctree).text()
		node = hg.hash(text, p1, p2)
		delta = hg.textdiff(base, text)
		log.append(Rev(delta, node, p1, p2, node))
		self.csets = RevLog(log, text)
		return node
	def addmf(self, text, p1, p2, cs):
		try:
			log, base = self.mfs
		except TypeError:
			log = []
			if p1 == hg.NULLID:
				base = ""
			else:
				base = self.revmap.get(p1, Mtree).text()
		node = hg.hash(text, p1, p2)
		delta = hg.textdiff(base, text)
		log.append(Rev(delta, node, p1, p2, cs))
		self.mfs = RevLog(log, text)
		return node
	def addfile(self, path, text, p1, p2, cs):
		try:
			log, base = self.files[path]
		except KeyError:
			log = []
			if p1 == hg.NULLID:
				base = ""
			else:
				base = self.revmap.get(p1, Ftree).text()
		node = hg.hash(text, p1, p2)
		delta = hg.textdiff(base, text)
		log.append(Rev(delta, node, p1, p2, cs))
		self.files[path] = RevLog(log, text)
		return node
	def tobundle(self):
		return hg.makebundle(self.clog, self.mlog, self.flog)

def main():
	"""Main function for Mercurial helper."""
	# Arguments should be:
	# 1. Name of remote, or full remote URL (with "hg::" prefix)
	# 2. Remote URL without prefix
	if len(sys.argv) != 3:
		die("expecting exactly two arguments")

	# ':' is illegal in Git refs but required in full URLs, so we
	# can use it to distinguish them here.
	rname = sys.argv[1] if ":" not in sys.argv[1] else None

	# Set up Mercurial objects: ui is settings/context
	hgui = hg.ui()
	# XXX set up proxy options and other stuff in ui
	remote = HgRemote(hgui, sys.argv[2], rname)

	# Handle commands issued by Git
	cmd = sys.stdin.readline().split(None, 1)
	importrefs = pushrefs = []
	while True:
		print(cmd, file=sys.stderr)

		# Blank line ends batch or command stream
		if len(cmd) == 0:
			if importrefs:
				remote.fastimport(importrefs)
				importrefs = []
				continue
			if pushrefs:
				remote.push(pushrefs)
				pushrefs = []
				continue
			break
		# Options can be issued during a batch
		if cmd[0] == "option":
			args = cmd[1].split(None, 1)
			if args[0] == "verbosity":
				option_verbosity(args[1])
			elif args[0] == "dry-run":
				option_dryrun(args[1])
			else:
				dbgprint("unsupported\n")
			sys.stdout.flush()
			continue

		# No other command is allowed to interrupt a batch
		if pushrefs and cmd[0] != "push":
			die("push batch interrupted")
		if importrefs and cmd[0] != "import":
			die("import batch interrupted")

		if cmd[0] == "import":
			importrefs.append(cmd[1])
		elif cmd[0] == "push":
			pushrefs.append(cmd[1])
		elif cmd[0] == "capabilities":
			remote.capabilities()
		elif cmd[0] == "list":
			remote.list()
		else:
			die("unrecognized command `%s'" % cmd[0])
		cmd = sys.stdin.readline().split(None, 1)


if __name__ == "__main__":
	main()
