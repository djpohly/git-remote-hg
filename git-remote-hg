#!/usr/bin/env python2
"""Used by git-remote to interact with remote Mercurial repositories.

This command should not be run by the user.  Rather, it is invoked by
the Git core when accessing remotes of the form `hg::HGURL', where
HGURL is any valid Mercurial repository URL.

Executed with two arguments: the name of the remote, and the remote
URL.  (For URLs specified directly on the command line, the name of
the remote is `hg::HGURL'.)
"""

from __future__ import print_function

import sys
from mercurial import hg, ui, node

def die(msg):
	print("%s: %s" % (progname, msg), file=sys.stderr)
	sys.exit(1)

def dbgprint(*vals, **kwargs):
	print(*vals, file=sys.stderr, **kwargs)
	print(*vals, **kwargs)


class hgremote(object):
	def __init__(self, name, peer):
		self.name = name
		self.peer = peer
		self.refmap = {}

	def capabilities(self):
		dbgprint("option")
		dbgprint("import")
		dbgprint("push")
		if self.name:
			dbgprint("refspec refs/heads/*:refs/remotes/%s/*" % self.name)
		dbgprint()
		sys.stdout.flush()

	def option(self, args):
		# XXX Either implement options, or don't advertise
		dbgprint("unsupported\n")
		sys.stdout.flush()

	def list(self):
		# heads() returns heads tipmost first.  What do we want to map HEAD to?
		# - Tipmost revision?  Possible, but probably not what we want.
		# - Tipmost revision on default branch?  More Git-like.
		# - Depends on TKPA of previous remote HEAD?  Sounds plausible.
		for name, sha in self.peer.listkeys("bookmarks").iteritems():
			self.refmap["bm/" + name] = sha
		seen = set(self.refmap.values())
		for name, heads in self.peer.branchmap().iteritems():
			i = 0
			for binsha in set(heads) - seen:
				self.refmap["br/" + name + "/" + str(i)] = node.hex(binsha)
				i += 1
		dbgprint(*["? " + name for name in self.refmap.iterkeys()], sep="\n")
		dbgprint("? HEAD")
		dbgprint()
		sys.stdout.flush()

def main():
	"""Main function for Mercurial helper."""
	# Arguments should be:
	# 1. Name of remote, or full remote URL (with "hg::" prefix)
	# 2. Remote URL without prefix
	if len(sys.argv) != 3:
		die("expecting exactly two arguments")

	# ':' is illegal in Git refs but required in full URLs, so we
	# can use it to distinguish them here.
	rname = sys.argv[1] if ":" not in sys.argv[1] else None

	# Set up Mercurial objects: ui is settings/context, and peer is the remote
	hgui = ui.ui()
	# XXX set up proxy options and other stuff in ui
	remote = hgremote(rname, hg.peer(hgui, {}, sys.argv[2]))

	# Handle commands issued by Git
	cmd = sys.stdin.readline().split(None, 1)
	while cmd:
		print(cmd, file=sys.stderr)

		if cmd[0] == "capabilities":
			remote.capabilities()
		elif cmd[0] == "option":
			remote.option(cmd[1:])
		elif cmd[0] == "list":
			remote.list()
		elif cmd[0] == "push":
			die("push not yet implemented")
		elif cmd[0] == "import":
			die("import not yet implemented")
		else:
			die("unrecognized command `%s'" % cmd[0])
		cmd = sys.stdin.readline().split(None, 1)


if __name__ == "__main__":
	progname = sys.argv[0].rsplit("/", 1)[-1]
	try:
		main()
	except Exception as ex:
		# Print standard-style command errors
		#die(ex)
		raise
