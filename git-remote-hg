#!/usr/bin/env python2
"""Used by git-remote to interact with remote Mercurial repositories.

This command should not be run by the user.  Rather, it is invoked by
the Git core when accessing remotes of the form `hg::HGURL', where
HGURL is any valid Mercurial repository URL.

Executed with two arguments: the name of the remote, and the remote
URL.  (For URLs specified directly on the command line, the name of
the remote is `hg::HGURL'.)
"""

import sys
from mercurial import hg, ui

def die(msg):
	print >> sys.stderr, "%s: %s" % (progname, msg)
	sys.exit(1)

def dbgprint(output):
	print >> sys.stderr, output,
	print output,
	sys.stdout.flush()

def capabilities(rname):
	dbgprint("option\n")
	dbgprint("import\n")
	dbgprint("push\n")
	if rname:
		dbgprint("refspec refs/heads/*:refs/remotes/%s/*\n" % rname)
	dbgprint("\n")

def option(args):
	# XXX Either implement options, or don't advertise
	dbgprint("unsupported\n")

def main():
	"""Main function for Mercurial helper."""
	# Arguments should be:
	# 1. Name of remote, or full remote URL (with "hg::" prefix)
	# 2. Remote URL without prefix
	if len(sys.argv) != 3:
		print >> sys.stderr, "%s: expecting exactly two arguments" % progname
		sys.exit(1)

	# ':' is illegal in Git refs but required in full URLs, so we
	# can use it to distinguish them here.
	rname = sys.argv[1] if ":" not in sys.argv[1] else None

	# Set up Mercurial objects: ui is settings/context, and peer is the remote
	hgui = ui.ui()
	# XXX set up proxy options and other stuff in ui
	hgpeer = hg.peer(hgui, {}, sys.argv[2])

	# Handle commands issued by Git
	cmd = sys.stdin.readline().split(None, 1)
	while cmd:
		print >> sys.stderr, cmd

		if cmd[0] == "capabilities":
			capabilities(rname)
		elif cmd[0] == "list":
			die("list not yet implemented")
		elif cmd[0] == "option":
			option(cmd[1:])
		elif cmd[0] == "push":
			die("push not yet implemented")
		elif cmd[0] == "import":
			die("import not yet implemented")
		else:
			print >> sys.stderr, "%s: unrecognized command `%s'" % (progname, cmd[0])
			sys.exit(1)
		cmd = sys.stdin.readline().split(None, 1)


if __name__ == "__main__":
	progname = sys.argv[0].rsplit("/", 1)[-1]
	try:
		main()
	except Exception as ex:
		# Print standard-style command errors
		print >> sys.stderr, "%s: %s" % (sys.argv[0], ex)
		sys.exit(1)
